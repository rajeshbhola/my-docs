---
title: Flow Control
---

**Flow control** describes the order in which statements are executed at runtime.

### Three Categories of Flow Control Statements

1. **Selection Statements** - Select one option among several available options
2. **Iterative Statements** - Execute statements repeatedly
3. **Transfer Statements** - Transfer control from one place to another

---

## 1. Selection Statements

### if-else Statement

**Syntax:**
```java
if (boolean_condition) {
    // action if true
} else {
    // action if false
}
```

#### Important Rules

**Rule 1: Argument must be boolean type**

The argument to the `if` statement must be boolean type. If you provide any other type, you will get a compile-time error.

**Valid:**
```java
boolean b = true;
if (b) {
    System.out.println("Hello");
}
```

**Invalid:**
```java
int x = 10;
if (x) { // Compile-time error: incompatible types found: int, required: boolean
    System.out.println("Hello");
}
```

**Invalid:**
```java
int x = 10;
if (x = 20) { // Compile-time error: incompatible types found: int, required: boolean
    System.out.println("Hello");
}
```

**Explanation:** `x = 20` is assignment, not comparison. It assigns 20 to x and results in int type, not boolean.

**Valid:**
```java
int x = 10;
if (x == 20) { // Comparison operator
    System.out.println("Hello");
} else {
    System.out.println("Hi");
}
// Output: Hi
```

**Assignment vs Comparison with boolean:**
```java
boolean b = true;
if (b = false) { // Valid (assignment results in boolean)
    System.out.println("Hello");
} else {
    System.out.println("Hi");
}
// Output: Hi (because b becomes false after assignment)
```

---

**Rule 2: else and curly braces are optional**

Without curly braces, only one statement is allowed under `if`, which should not be a declarative statement.

**Valid:**
```java
if (true)
    System.out.println("Hello");
```

**Valid:**
```java
if (true);
// semicolon is a valid Java statement (empty statement)
```

**Invalid:**
```java
if (true)
    int x = 10; // Compile-time error: not a statement
```

**Why invalid?** Without curly braces, you can take only one statement under `if`, which should not be a declarative statement.

**Explanation:** `int x = 10` is a local variable of the if block. Once the semicolon completes, the if block completes. In the remaining lines, you cannot use `x` because it's a local variable of the if block. Since you're declaring a variable but cannot use it, the compiler gives an error.

**Valid:**
```java
if (true) {
    int x = 10;
    // Can use x here
}
```

---

**Note: Semicolon is a valid Java statement**

Semicolon is a valid Java statement which is also known as an **empty statement**.

---

### Dangling else Problem

There is **no dangling else problem in Java**. Every `else` is mapped to the nearest `if` statement.

**Example:**
```java
if (true)
    if (true)
        System.out.println("Hello");
else
    System.out.println("Hi");
```

The `else` belongs to the **nearest if** (second if), not the first one.

---

## 2. switch Statement

### When to Use switch

If several options are available, **never recommended to use nested if-else**. Highly recommended to use **switch statement** for better readability.

**if-else approach (not recommended):**
```java
if (x == 1) {
    System.out.println("Jan");
} else if (x == 2) {
    System.out.println("Feb");
} else if (x == 3) {
    System.out.println("March");
}
// ... and so on
```

**switch approach (recommended):**
```java
switch (x) {
    case 1:
        System.out.println("Jan");
        break;
    case 2:
        System.out.println("Feb");
        break;
    case 3:
        System.out.println("March");
        break;
    // ...
}
```

---

### Syntax

```java
switch (x) {
    case 1:
        action1;
        break;
    case 2:
        action2;
        break;
    case n:
        actionN;
        break;
    default:
        default_action;
}
```

---

### Important Rules for switch

#### Rule 1: Allowed Argument Types

**Until Java 1.4:**
- `byte`, `short`, `char`, `int`

**From Java 1.5 onwards:**
- `byte`, `short`, `char`, `int`
- Corresponding wrapper classes: `Byte`, `Short`, `Character`, `Integer`
- `enum` type

**From Java 1.7 onwards:**
- All above types
- `String` type

**Not allowed:**
- `boolean` - If boolean allowed, only two cases (true/false) possible. Better to use if-else.
- `long` - int range is sufficient for practical cases. More than int range never required.
- `float`, `double` - Between 0 and 1, infinite values exist (0.1, 0.11, 0.001...). Cannot define infinite cases.

---

#### Rule 2: Curly Braces are Mandatory

**Exception:** switch is the only place where curly braces are mandatory. Everywhere else (if, while, for, do-while, foreach), curly braces are optional.

---

#### Rule 3: Both case and default are Optional

Both `case` and `default` are optional. An empty switch statement is a valid Java syntax.

**Valid:**
```java
int x = 10;
switch (x) {
}
```

---

#### Rule 4: Every Statement Inside switch Must Be Under case or default

Independent statements are not allowed inside switch.

**Invalid:**
```java
int x = 10;
switch (x) {
    System.out.println("Hello"); // Compile-time error: case, default, or } expected
}
```

**Valid:**
```java
int x = 10;
switch (x) {
    case 10:
        System.out.println("Hello");
        break;
}
```

---

#### Rule 5: Every case Label Must Be Compile-Time Constant

**Valid:**
```java
int x = 10, y = 20;
switch (x) {
    case 10:
        System.out.println("10");
        break;
    case 20:
        System.out.println("20");
        break;
}
```

**Invalid:**
```java
int x = 10, y = 20;
switch (x) {
    case 10:
        System.out.println("10");
        break;
    case y: // Compile-time error: constant expression required
        System.out.println("20");
        break;
}
```

**Valid if y is final:**
```java
int x = 10;
final int y = 20;
switch (x) {
    case 10:
        System.out.println("10");
        break;
    case y: // Valid (y is compile-time constant)
        System.out.println("20");
        break;
}
```

---

#### Rule 6: Both switch Argument and case Label Can Be Expressions

**Valid:**
```java
int x = 10;
switch (x + 1) { // Expression allowed
    case 10:
        System.out.println("10");
        break;
    case 10 + 20 + 30: // Constant expression allowed
        System.out.println("60");
        break;
}
```

**Rule:** Both switch argument and case label can be expressions, but case label should be a **constant expression**.

---

#### Rule 7: Every case Label Must Be in the Range of switch Argument Type

**Invalid:**
```java
byte b = 10;
switch (b) {
    case 10:
        System.out.println("10");
        break;
    case 100:
        System.out.println("100");
        break;
    case 1000: // Compile-time error: possible loss of precision found: int, required: byte
        System.out.println("1000");
        break;
}
```

**Explanation:** byte range is -128 to 127. case 1000 is not possible.

**Valid:**
```java
byte b = 10;
switch (b + 1) { // b + 1 results in int type
    case 10:
        System.out.println("10");
        break;
    case 100:
        System.out.println("100");
        break;
    case 1000: // Valid (switch argument is int type)
        System.out.println("1000");
        break;
}
```

---

#### Rule 8: Duplicate case Labels Not Allowed

**Invalid:**
```java
int x = 10;
switch (x) {
    case 97:
        System.out.println("97");
        break;
    case 98:
        System.out.println("98");
        break;
    case 'a': // Compile-time error: duplicate case label ('a' = 97)
        System.out.println("a");
        break;
}
```

---

### Fall Through Inside switch

**If any case is matched, from that case onwards, all statements will be executed until break or end of switch.** This is called **fall through inside switch**.

**Example:**
```java
int x = 0;
switch (x) {
    case 0:
        System.out.println("0");
    case 1:
        System.out.println("1");
        break;
    case 2:
        System.out.println("2");
    default:
        System.out.println("default");
}
```

| x value | Output |
|---------|--------|
| 0       | 0, 1   |
| 1       | 1      |
| 2       | 2, default |
| 3       | default |

---

**Advantage of Fall Through:**

For multiple cases, we can define common action.

**Example:**
```java
switch (x) {
    case 1:
    case 2:
    case 3:
        System.out.println("Q4");
        break;
    case 4:
    case 5:
    case 6:
        System.out.println("Q1");
        break;
    // ...
}
```

The main advantage of fall through inside switch is **code reusability** - we can define common action for multiple cases.

---

### default Case Rules

1. Within the switch, we can take default case **at most once** (either zero times or one time)
2. default case will be executed **if and only if there is no case matched**
3. Within the switch, we can write default case **anywhere**, but it is recommended to write as the **last case**

**Example:**
```java
int x = 0;
switch (x) {
    default:
        System.out.println("default");
    case 0:
        System.out.println("0");
        break;
    case 1:
        System.out.println("1");
    case 2:
        System.out.println("2");
}
```

| x value | Output |
|---------|--------|
| 0       | 0      |
| 1       | 1, 2   |
| 2       | 2      |
| 3       | default, 0 |

---

## 3. Iterative Statements

### while Loop

#### When to Use while

If we **don't know the number of iterations in advance**, then highly recommended to go for **while loop**.

**Examples:**
- `while (rs.next())` - Don't know how many records in ResultSet
- `while (e.hasMoreElements())` - Don't know how many elements in Enumeration
- `while (it.hasNext())` - Don't know how many elements in Iterator

---

#### Syntax

```java
while (boolean_condition) {
    // action
}
```

---

#### Important Rules

**Rule 1: Argument must be boolean type**

The argument should be boolean type. If you are trying to provide any other type, you will get compile-time error.

**Invalid:**
```java
while (1) {
    System.out.println("Hello");
}
// Compile-time error: incompatible types found: int, required: boolean
```

**In C/C++:** `while (1)` is valid (1 means true). **In Java:** Not valid.

---

**Rule 2: Curly braces are optional**

Without curly braces, we can take only one statement under while, which should not be a declarative statement.

**Valid:**
```java
while (true)
    System.out.println("Hello");
```

**Valid:**
```java
while (true);
// semicolon is a valid Java statement
```

**Invalid:**
```java
while (true)
    int x = 10; // Compile-time error
```

---

### Unreachability Problem in while Loop

**Example 1:**
```java
while (true) {
    System.out.println("Hello");
}
System.out.println("Hi"); // Compile-time error: unreachable statement
```

**Example 2:**
```java
while (false) {
    System.out.println("Hello"); // Compile-time error: unreachable statement
}
System.out.println("Hi");
```

**Example 3:**
```java
int a = 10, b = 20;
while (a < b) {
    System.out.println("Hello");
}
System.out.println("Hi");
// Valid (compiler doesn't know if true or false because variables are not final)
// Output: Hello (infinite times)
```

**Example 4:**
```java
int a = 10, b = 20;
while (a > b) {
    System.out.println("Hello");
}
System.out.println("Hi");
// Valid (compiler doesn't know the result)
// Output: Hi
```

**Example 5:**
```java
final int a = 10, b = 20;
while (a < b) {
    System.out.println("Hello");
}
System.out.println("Hi"); // Compile-time error: unreachable statement
```

**Explanation:** `a` and `b` are final variables. Compiler knows `10 < 20` is always true. Loop will run infinitely, so "Hi" is unreachable.

**Example 6:**
```java
final int a = 10, b = 20;
while (a > b) {
    System.out.println("Hello"); // Compile-time error: unreachable statement
}
System.out.println("Hi");
```

**Explanation:** Compiler knows `10 > 20` is false. Loop body will never execute, so it's unreachable.

---

**Note on Final Variables:**

1. **Every final variable will be replaced by its value at compile-time**
2. **If both arguments are compile-time constants, that operation should be performed at compile-time**

**Example:**
```java
final int a = 10;
int b = 20;

System.out.println(a + b);
// After compilation: System.out.println(10 + b);

final int c = 20;
System.out.println(a + c);
// After compilation: System.out.println(30);
```

---

### do-while Loop

#### When to Use do-while

If we want to execute loop body **at least once**, then we should go for **do-while**.

---

#### Syntax

```java
do {
    // body
} while (boolean_condition);
```

**Note:** Semicolon is **mandatory** after while in do-while. In C++, semicolon is optional, but in Java, it's mandatory.

---

#### Difference Between while and do-while

| while Loop | do-while Loop |
|------------|---------------|
| Loop body may be executed zero times | Loop body will be executed at least once |

---

#### Important Rules

**Rule 1: Curly braces are optional**

Without curly braces, only one statement is allowed between `do` and `while`, which should not be a declarative statement.

**Valid:**
```java
do
    System.out.println("Hello");
while (true);
```

**Valid:**
```java
do;
while (true);
```

**Invalid:**
```java
do
    int x = 10;
while (true);
// Compile-time error
```

---

**Important Example:**

**Valid:**
```java
do
    while (true)
        System.out.println("Hello");
while (false);
```

**Explanation:**
- Between `do` and `while`, there is **one statement**: the `while` loop
- SOP is part of the inner while loop
- First half of do-while is reachable, so no compile-time error
- Output: Hello (infinite times)

---

### Unreachability Problem in do-while

Same unreachability rules apply as in while loop.

**Example 1:**
```java
do {
    System.out.println("Hello");
} while (true);
System.out.println("Hi"); // Compile-time error: unreachable statement
```

**Example 2:**
```java
do {
    System.out.println("Hello");
} while (false);
System.out.println("Hi");
// Valid
// Output: Hello, Hi
```

**Example 3:**
```java
int a = 10, b = 20;
do {
    System.out.println("Hello");
} while (a < b);
System.out.println("Hi");
// Valid (compiler doesn't know the result)
// Output: Hello (infinite times)
```

**Example 4:**
```java
int a = 10, b = 20;
do {
    System.out.println("Hello");
} while (a > b);
System.out.println("Hi");
// Valid
// Output: Hello, Hi
```

**Example 5:**
```java
final int a = 10, b = 20;
do {
    System.out.println("Hello");
} while (a < b);
System.out.println("Hi"); // Compile-time error: unreachable statement
```

**Example 6:**
```java
final int a = 10, b = 20;
do {
    System.out.println("Hello");
} while (a > b);
System.out.println("Hi");
// Valid
// Output: Hello, Hi
```

---

## 4. for Loop

### When to Use for Loop

**for loop is the most commonly used loop in Java.**

If we **know the number of iterations in advance**, then for loop is the best choice.

---

### Syntax

```java
for (initialization; conditional_check; increment/decrement) {
    // loop body
}
```

**Execution Order:**
1. Initialization section (executed only once)
2. Conditional check
3. Loop body
4. Increment/decrement
5. Go back to step 2

---

### Important Rules for Initialization Section

**Rule 1: This part will be executed only once in loop life cycle**

**Rule 2: Here we can declare and initialize local variables of the for loop**

**Rule 3: We can declare any number of variables, but should be of the same type**

**Valid:**
```java
for (int i = 0, j = 0; i < 10; i++) {
    System.out.println("Hello");
}
```

**Invalid:**
```java
for (int i = 0, String s = "Durga"; i < 10; i++) {
    // Compile-time error
}
```

**Invalid:**
```java
for (int i = 0; int j = 0; i < 10; i++) {
    // Compile-time error (second declaration becomes conditional check)
}
```

**Rule 4: In the initialization section, we can take any valid Java statement including SOP**

**Valid:**
```java
int i = 0;
for (System.out.println("Hello, you are sleeping"); i < 3; i++) {
    System.out.println("No boss, you only sleeping");
}
// Output:
// Hello, you are sleeping
// No boss, you only sleeping
// No boss, you only sleeping
// No boss, you only sleeping
```

---

### Important Rules for Conditional Check

**Rule 1: We can take any valid Java expression, but should be of boolean type**

**Rule 2: This part is optional. If we are not taking anything, compiler will always place true**

**Example:**
```java
for (System.out.println("Hello"); ; i++) {
    System.out.println("Hi");
    System.out.println(i);
}
// Infinite loop (condition is true by default)
```

---

### Important Rules for Increment/Decrement Section

**In the increment/decrement section, we can take any valid Java statement including SOP.**

**Example:**
```java
int i = 0;
for (System.out.println("Hello"); i < 3; System.out.println("Hi"), i++) {
}
// Output: Hello, Hi, Hi, Hi
```

---

### All Three Parts are Independent and Optional

```java
for (;;) {
    System.out.println("Hello");
}
// Valid (infinite loop)
// Compiler places true for conditional check
```

```java
for (;;);
// Valid (infinite loop, empty statement)
```

---

### Curly Braces are Optional

Without curly braces, only one statement is allowed under for, which should not be a declarative statement.

**Valid:**
```java
for (int i = 0; i < 10; i++)
    System.out.println("Hello");
```

**Valid:**
```java
for (int i = 0; i < 10; i++);
```

**Invalid:**
```java
for (int i = 0; i < 10; i++)
    int x = 10;
```

---

### Unreachability Problem in for Loop

Same unreachability rules apply.

**Example 1:**
```java
for (int i = 0; true; i++) {
    System.out.println("Hello");
}
System.out.println("Hi"); // Compile-time error: unreachable statement
```

**Example 2:**
```java
for (int i = 0; false; i++) {
    System.out.println("Hello"); // Compile-time error: unreachable statement
}
System.out.println("Hi");
```

**Example 3:**
```java
for (int i = 0; ; i++) {
    System.out.println("Hello");
}
System.out.println("Hi"); // Compile-time error: unreachable statement (condition is true by default)
```

**Example 4:**
```java
int a = 10, b = 20;
for (int i = 0; a < b; i++) {
    System.out.println("Hello");
}
System.out.println("Hi");
// Valid (compiler doesn't know the result)
// Output: Hello (infinite times)
```

**Example 5:**
```java
int a = 10, b = 20;
for (int i = 0; a > b; i++) {
    System.out.println("Hello");
}
System.out.println("Hi");
// Valid
// Output: Hi
```

**Example 6:**
```java
final int a = 10, b = 20;
for (int i = 0; a < b; i++) {
    System.out.println("Hello");
}
System.out.println("Hi"); // Compile-time error: unreachable statement
```

**Example 7:**
```java
final int a = 10, b = 20;
for (int i = 0; a > b; i++) {
    System.out.println("Hello"); // Compile-time error: unreachable statement
}
System.out.println("Hi");
```

---

## 5. for-each Loop (Enhanced for Loop)

### Introduction

- **Also known as:** Enhanced for loop
- **Introduced in:** Java 1.5
- **Purpose:** Specially designed loop to retrieve elements of **arrays and collections**

---

### for-each Loop is the Best Choice to Retrieve Elements of Arrays and Collections

**Syntax:**
```java
for (item_type item : target) {
    // body
}
```

- **target:** Can be array or collection
- **item:** Each element in the target

---

### Example 1: Print Elements of One-Dimensional Array

**Normal for loop:**
```java
int[] x = {10, 20, 30, 40, 50};
for (int i = 0; i < x.length; i++) {
    System.out.println(x[i]);
}
```

**Enhanced for loop:**
```java
int[] x = {10, 20, 30, 40, 50};
for (int x1 : x) {
    System.out.println(x1);
}
```

**for each int value x1 in x, print that x1 value**

---

### Example 2: Print Elements of Two-Dimensional Array

**Normal for loop:**
```java
int[][] x = {{10, 20, 30}, {40, 50}};
for (int i = 0; i < x.length; i++) {
    for (int j = 0; j < x[i].length; j++) {
        System.out.println(x[i][j]);
    }
}
```

**Enhanced for loop:**
```java
int[][] x = {{10, 20, 30}, {40, 50}};
for (int[] x1 : x) { // for each one-dimensional array x1 in x
    for (int x2 : x1) { // for each int value x2 in x1
        System.out.println(x2);
    }
}
```

---

### Example 3: Print Elements of Three-Dimensional Array

**Enhanced for loop:**
```java
int[][][] x = {
    {{10, 20, 30}, {40, 50}},
    {{60, 70}, {80, 90}}
};

for (int[][] x1 : x) { // for each two-dimensional array x1 in x
    for (int[] x2 : x1) { // for each one-dimensional array x2 in x1
        for (int x3 : x2) { // for each int value x3 in x2
            System.out.println(x3);
        }
    }
}
```

---

### Limitations of for-each Loop

#### Limitation 1: Applicable Only for Arrays and Collections

for-each loop is the best choice to retrieve elements of arrays and collections, but **its limitation is it is applicable only for arrays and collections**. It is **not a general-purpose loop**.

**Cannot write equivalent for-each loop for:**
```java
for (int i = 0; i < 10; i++) {
    System.out.println("Hello");
}
```

---

#### Limitation 2: Only in Original Order, Not Reverse Order

By using normal for loop, we can print array elements either in original order or in reverse order. But by using for-each loop, we can print array elements **only in original order but not in reverse order**.

**Reverse order with normal for loop:**
```java
int[] x = {10, 20, 30, 40, 50};
for (int i = x.length - 1; i >= 0; i--) {
    System.out.println(x[i]);
}
// Output: 50, 40, 30, 20, 10
```

**We cannot write equivalent for-each loop directly for this.**

---

### Iterable Interface

The target element in for-each loop should be an **iterable object**.

An object is said to be **iterable** if and only if the corresponding class implements **java.lang.Iterable** interface.

**Iterable interface:**
- **Introduced in:** Java 1.5
- **Contains:** Only one method: `public Iterator iterator()`

**All array-related classes and collection-implemented classes already implement Iterable.** Being a programmer, we are not required to do anything. We should just be aware of this point.

---

### Difference Between Iterable and Iterator

| Iterable | Iterator |
|----------|----------|
| Related to for-each loop | Related to collections |
| The target element in for-each loop should be iterable | We can use to retrieve elements of collections one by one |
| Present in java.lang package | Present in java.util package |
| It contains one method: `iterator()` | It contains three methods: `hasNext()`, `next()`, `remove()` |

---

## 6. Transfer Statements

### break Statement

We can use break statement in the following places:

#### 1. Inside switch (to stop fall through)

**Example:**
```java
int x = 0;
switch (x) {
    case 0:
        System.out.println("0");
    case 1:
        System.out.println("1");
        break;
    case 2:
        System.out.println("2");
    default:
        System.out.println("default");
}
// Output: 0, 1
```

---

#### 2. Inside Loops (to break loop execution based on some condition)

**Example:**
```java
for (int i = 0; i < 10; i++) {
    if (i == 5)
        break;
    System.out.println(i);
}
// Output: 0, 1, 2, 3, 4
```

---

#### 3. Inside Labeled Blocks (to break block execution based on some condition)

**Example:**
```java
int x = 10;
L1: {
    System.out.println("begin");
    if (x == 10)
        break L1;
    System.out.println("end");
}
System.out.println("hello");
// Output: begin, hello
```

---

**These are the only places where we can use break statement.** If we are using break statement anywhere else, we will get compile-time error saying: **"break outside switch or loop"**

**Invalid:**
```java
int x = 10;
if (x == 10)
    break; // Compile-time error: break outside switch or loop
System.out.println("Hello");
```

---

### continue Statement

We can use continue statement **only inside loops** to skip current iteration and continue for the next iteration.

**Example:**
```java
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0)
        continue;
    System.out.println(i);
}
// Output: 1, 3, 5, 7, 9
```

---

**We can use continue statement only inside loops.** If we are using anywhere else, we will get compile-time error saying: **"continue outside of loop"**

**Invalid:**
```java
int x = 10;
if (x == 10)
    continue; // Compile-time error: continue outside of loop
System.out.println("Hello");
```

---

### Labeled break and continue

We can use labeled break and continue to **break or continue a particular loop in nested loops**.

**Example:**
```java
L1: for (int i = 0; i < 3; i++) {
    L2: for (int j = 0; j < 3; j++) {
        if (i == j)
            break L1; // breaks outer loop
        System.out.println(i + "..." + j);
    }
}
// Output: (nothing, because when i=0, j=0, outer loop breaks immediately)
```

**Example with different break/continue:**
```java
L1: for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == j)
            break; // breaks inner loop
        System.out.println(i + "..." + j);
    }
}
// Output: 1...0, 2...0, 2...1
```

**Example with continue:**
```java
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == j)
            continue; // skips current iteration of inner loop
        System.out.println(i + "..." + j);
    }
}
// Output: 0...1, 0...2, 1...0, 1...2, 2...0, 2...1
```

**Example with continue L1:**
```java
L1: for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == j)
            continue L1; // continues outer loop
        System.out.println(i + "..." + j);
    }
}
// Output: 1...0, 2...0, 2...1
```

---

### do-while vs continue (Dangerous Combination)

**This is a dangerous combination** - most people get the answer wrong.

**Example:**
```java
int x = 0;
do {
    x++;
    System.out.println(x);
    if (++x < 5)
        continue;
    x++;
    System.out.println(x);
} while (++x < 10);
```

**Execution:**
1. `x = 0`
2. `x++` → `x = 1`
3. Print `1`
4. `++x` → `x = 2`, check `2 < 5` → true
5. **continue** → control goes to `while (++x < 10)`, NOT to the first statement
6. `++x` → `x = 3`, check `3 < 10` → true
7. Go back to do block
8. `x++` → `x = 4`
9. Print `4`
10. `++x` → `x = 5`, check `5 < 5` → false
11. Continue won't execute
12. `x++` → `x = 6`
13. Print `6`
14. `while (++x < 10)` → `x = 7`, check `7 < 10` → true
15. Go back to do block
16. Continue pattern...

**Output:** `1, 4, 6, 8, 10`

**Important:** In do-while, when continue is executed, control goes to the **while condition check**, not to the first statement of the do block. If the condition is true, then it executes the do block again.

---

## Summary: Key Points to Remember

### Selection Statements

1. **if-else:**
   - Argument must be boolean type
   - else and curly braces are optional
   - Without curly braces, only one statement allowed (not declarative)
   - No dangling else problem - else maps to nearest if

2. **switch:**
   - Use when several options available (better readability than nested if-else)
   - Allowed types: byte, short, char, int, wrapper classes (1.5+), enum (1.5+), String (1.7+)
   - Curly braces are mandatory (only place where mandatory)
   - Both case and default are optional
   - Every statement must be under case or default
   - case labels must be compile-time constants
   - case labels must be in range of switch argument type
   - Duplicate case labels not allowed
   - Fall through: from matched case, all statements execute until break or end
   - default executed only if no case matched

### Iterative Statements

1. **while:**
   - Use when number of iterations not known in advance
   - Argument must be boolean type
   - Curly braces optional
   - Loop body may execute zero times

2. **do-while:**
   - Use when loop body must execute at least once
   - Semicolon mandatory after while
   - Curly braces optional
   - Loop body executes at least once

3. **for:**
   - Most commonly used loop
   - Use when number of iterations known in advance
   - All three parts (initialization, condition, increment/decrement) are independent and optional
   - Can declare multiple variables of same type in initialization
   - Can take any valid Java statement in any part (including SOP)

4. **for-each (enhanced for):**
   - Introduced in Java 1.5
   - Best choice to retrieve elements of arrays and collections
   - Target must be iterable object
   - Limitations: Only for arrays/collections, only in original order

### Unreachability

- Compiler checks for unreachable statements
- JVM doesn't check unreachability (only executes)
- For final variables, compiler knows values at compile-time
- For normal variables, compiler doesn't know values (evaluated at runtime)

### Transfer Statements

1. **break:**
   - Inside switch (stop fall through)
   - Inside loops (break loop execution)
   - Inside labeled blocks (break block execution)
   - Error if used elsewhere: "break outside switch or loop"

2. **continue:**
   - Only inside loops (skip current iteration, continue next)
   - Error if used elsewhere: "continue outside of loop"

3. **Labeled break/continue:**
   - Break or continue a particular loop in nested loops

4. **do-while vs continue:**
   - continue goes to while condition, not first statement of do block

### Important Notes

- **Semicolon** is a valid Java statement (empty statement)
- **Final variables**: Replaced by value at compile-time
- **Iterable interface**: java.lang.Iterable (1.5+), contains `iterator()` method
- **Iterator interface**: java.util.Iterator, contains `hasNext()`, `next()`, `remove()`