---
title: Exception Handling
---

### What is an Exception?
An **exception** is an unwanted, unexpected event that disturbs the normal flow of a program.

**Examples:**
- **File not found exception**: Trying to read data from a remote file in London, but at runtime the file is not available
- **Tire puncture exception**: On your way to office, your bike tire gets punctured
- **Sleeping exception**: During a class, you fall asleep and can't learn the material

### Purpose of Exception Handling
The main purpose is **graceful termination** of the program. If something goes wrong, we should not miss anything or lose any resources.

**Example without exception handling:**
```
Open DB connection
Read data from database  // Problem occurs here
Close DB connection      // This never executes - connection wasted
```

If an exception occurs while reading data and we don't handle it, the program terminates abnormally and the database connection is never closed. This wastes resources.

### Meaning of Exception Handling
Exception handling means defining an **alternative way to continue the rest of the program normally**.

**Example:**
```java
try {
    // Read data from remote file in London
} catch (FileNotFoundException e) {
    // Use local file instead
    // Continue rest of program normally
}
```

---

## Runtime Stack Mechanism

For every thread, JVM creates one **runtime stack**. Every method call performed by that thread creates one entry in the stack called a **stack frame** or **activation record**.

**Example:**
```java
class Test {
    public static void main(String[] args) {
        doStuff();
    }
    
    public static void doStuff() {
        doMoreStuff();
    }
    
    public static void doMoreStuff() {
        System.out.println("hello");
    }
}
```

**Stack execution:**
1. Main thread calls `main()` → Entry added to stack
2. `main()` calls `doStuff()` → Entry added to stack
3. `doStuff()` calls `doMoreStuff()` → Entry added to stack
4. `doMoreStuff()` prints "hello" → Completes, entry removed
5. Control returns to `doStuff()` → Completes, entry removed
6. Control returns to `main()` → Completes, entry removed
7. Stack becomes empty → JVM destroys the stack before terminating the thread

---

## Default Exception Handling in Java

When an exception is raised and not handled:

1. The method where the exception occurred creates an exception object containing:
   - Name of the exception
   - Description of the exception
   - Stack trace (location where problem occurred)

2. This object is handed over to the JVM

3. JVM checks if the method has handling code:
   - If NO → JVM terminates the method abnormally and removes it from the stack
   - JVM asks the caller method to handle
   - This continues until `main()` method
   
4. If no method handles it, JVM hands it to the **Default Exception Handler**

5. Default Exception Handler prints exception information in this format:
   ```
   Exception in thread "main" java.lang.ArithmeticException: / by zero
       at Test.doMoreStuff(Test.java:line)
       at Test.doStuff(Test.java:line)
       at Test.main(Test.java:line)
   ```

6. Program terminates abnormally

**Example:**
```java
class Test {
    public static void main(String[] args) {
        doStuff();
    }
    
    public static void doStuff() {
        doMoreStuff();
    }
    
    public static void doMoreStuff() {
        System.out.println(10/0);  // ArithmeticException
    }
}
```

Output:
```
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Test.doMoreStuff
    at Test.doStuff
    at Test.main
```

---

## Exception Hierarchy

**Throwable** is the root class for all exceptions and errors in Java.

```
Throwable
├── Exception
│   ├── RuntimeException (unchecked)
│   │   ├── ArithmeticException
│   │   ├── NullPointerException
│   │   ├── ClassCastException
│   │   ├── IndexOutOfBoundsException
│   │   │   ├── ArrayIndexOutOfBoundsException
│   │   │   └── StringIndexOutOfBoundsException
│   │   ├── IllegalArgumentException
│   │   │   └── NumberFormatException
│   │   └── IllegalStateException
│   ├── IOException (checked)
│   │   ├── EOFException
│   │   └── FileNotFoundException
│   ├── InterruptedException (checked)
│   ├── SQLException (checked)
│   └── RemoteException (checked)
└── Error (unchecked)
    ├── VirtualMachineError
    │   ├── StackOverflowError
    │   └── OutOfMemoryError
    ├── LinkageError
    │   └── NoClassDefFoundError
    ├── AssertionError
    └── ExceptionInInitializerError
```

### Exception vs Error

**Exception:**
- Caused by our program
- Recoverable
- Programmer is responsible to handle

**Error:**
- NOT caused by our program
- Due to lack of system resources
- Non-recoverable
- Examples: OutOfMemoryError, StackOverflowError, VirtualMachineError

---

## Checked vs Unchecked Exceptions

### Checked Exceptions
Exceptions that are **checked by compiler** whether programmer is handling them or not, for smooth execution at runtime.

**Important:** Checked exceptions occur at **runtime**, NOT compile time. The compiler just checks if you've written handling code.

**Examples:**
- FileNotFoundException
- IOException
- InterruptedException
- SQLException

**Compiler error if not handled:**
```
unreported exception FileNotFoundException; must be caught or declared to be thrown
```

### Unchecked Exceptions
Exceptions that compiler does NOT check whether you're handling them or not.

**All unchecked exceptions:**
- RuntimeException and all its child classes
- Error and all its child classes

**Examples:**
- ArithmeticException
- NullPointerException
- ArrayIndexOutOfBoundsException
- All errors (StackOverflowError, OutOfMemoryError, etc.)

### Fully Checked vs Partially Checked

**Fully Checked:** Exception is checked AND all its child classes are also checked
- Examples: IOException, InterruptedException, SQLException

**Partially Checked:** Exception is checked BUT some child classes are unchecked
- Only TWO partially checked exceptions in Java:
  - **Throwable** (has Error as unchecked child)
  - **Exception** (has RuntimeException as unchecked child)

---

## Customized Exception Handling with try-catch

### Basic Syntax
```java
try {
    // Risky code - code that may raise an exception
} catch (ExceptionType e) {
    // Handling code - alternative flow
}
```

**Inside try block:** Write risky code (code which may raise an exception)

**Inside catch block:** Write handling code (what to do if exception occurs)

### Example Without Exception Handling
```java
class Test {
    public static void main(String[] args) {
        System.out.println("statement 1");
        System.out.println(10/0);  // ArithmeticException - abnormal termination
        System.out.println("statement 3");  // Never executes
    }
}
```

Output:
```
statement 1
Exception in thread "main" java.lang.ArithmeticException: / by zero
```

### Example With Exception Handling
```java
class Test {
    public static void main(String[] args) {
        System.out.println("statement 1");
        try {
            System.out.println(10/0);
        } catch (ArithmeticException e) {
            System.out.println(10/2);  // Alternative: 5
        }
        System.out.println("statement 3");
    }
}
```

Output:
```
statement 1
5
statement 3
```

This is **normal termination** - we handled the exception and continued normally.

---

## Control Flow in try-catch

```java
try {
    statement1;
    statement2;
    statement3;
} catch (Exception e) {
    statement4;
}
statement5;
```

### Case 1: No Exception
- Executes: 1, 2, 3, 5
- Does NOT execute: 4
- Result: Normal termination

### Case 2: Exception at statement2, catch block matched
- Executes: 1, 4, 5
- Does NOT execute: 2 (partially), 3
- Result: Normal termination

**Important:** If exception occurs inside try block, the rest of the try block won't execute even if we handle the exception.

### Case 3: Exception at statement2, catch block NOT matched
- Executes: 1
- Does NOT execute: 2 (partially), 3, 4, 5
- Result: Abnormal termination

### Case 4: Exception at statement4 or statement5
Result: Always abnormal termination

**Reason:** Catch block is only responsible for exceptions inside the try block. Exceptions outside try block are not handled.

---

## Methods to Print Exception Information

All three methods are present in **Throwable** class:

### 1. printStackTrace()
Prints: Name + Description + Stack trace

```java
try {
    System.out.println(10/0);
} catch (ArithmeticException e) {
    e.printStackTrace();
}
```

Output:
```
java.lang.ArithmeticException: / by zero
    at Test.main(Test.java:5)
```

### 2. toString()
Prints: Name + Description (no stack trace)

```java
try {
    System.out.println(10/0);
} catch (ArithmeticException e) {
    System.out.println(e);  // or e.toString()
}
```

Output:
```
java.lang.ArithmeticException: / by zero
```

### 3. getMessage()
Prints: Description only

```java
try {
    System.out.println(10/0);
} catch (ArithmeticException e) {
    System.out.println(e.getMessage());
}
```

Output:
```
/ by zero
```

**Default Exception Handler always uses `printStackTrace()`.**

---

## try with Multiple catch Blocks

### Why Multiple catch Blocks?
The way of handling an exception varies from exception to exception. Different exceptions need different handling code.

**NOT Recommended (same handling for all):**
```java
try {
    // risky code
} catch (Exception e) {
    // Same handling for all exceptions
}
```

**Recommended (different handling for each):**
```java
try {
    // risky code
} catch (ArithmeticException e) {
    // Perform alternative arithmetic operation
} catch (FileNotFoundException e) {
    // Use local file instead of remote file
} catch (SQLException e) {
    // Use Oracle database instead of MySQL
} catch (Exception e) {
    // Default handling code for other exceptions
}
```

### Order of catch Blocks is Important
**Rule:** Child exception first, then parent exception

**Invalid (parent first):**
```java
try {
    System.out.println(10/0);
} catch (Exception e) {          // Parent
    System.out.println("Exception");
} catch (ArithmeticException e) {  // Child - COMPILE ERROR
    System.out.println("ArithmeticException");
}
```

Compile error:
```
exception java.lang.ArithmeticException has already been caught
```

**Valid (child first):**
```java
try {
    System.out.println(10/0);
} catch (ArithmeticException e) {  // Child
    System.out.println("ArithmeticException");
} catch (Exception e) {            // Parent
    System.out.println("Exception");
}
```

---

## finally Block

### Purpose
To maintain **cleanup code** or **resource deallocation code** (like closing database connections, files, network connections).

### Speciality
finally block will **always be executed**, whether:
- Exception is raised or not raised
- Exception is handled or not handled
- Even in case of abnormal termination

### Example 1: No Exception
```java
try {
    System.out.println("try");
} catch (Exception e) {
    System.out.println("catch");
} finally {
    System.out.println("finally");
}
```

Output:
```
try
finally
```

### Example 2: Exception Raised and Handled
```java
try {
    System.out.println("try");
    System.out.println(10/0);
} catch (ArithmeticException e) {
    System.out.println("catch");
} finally {
    System.out.println("finally");
}
```

Output:
```
try
catch
finally
```

### Example 3: Exception Raised but NOT Handled (Abnormal Termination)
```java
try {
    System.out.println("try");
    System.out.println(10/0);
} catch (NullPointerException e) {  // Wrong exception type
    System.out.println("catch");
} finally {
    System.out.println("finally");
}
```

Output:
```
try
finally
Exception in thread "main" java.lang.ArithmeticException: / by zero
```

**Note:** Even in abnormal termination, finally block executes before termination.

### Practical Use Case
```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("input.txt"));
    // Use br to read data
} catch (IOException e) {
    // Handle exception
} finally {
    if (br != null) {
        br.close();  // Always close the resource
    }
}
```

---

## finally vs return Statement

### finally Block Dominates return Statement

**Example:**
```java
public static int m1() {
    try {
        return 7;
    } finally {
        return 9;
    }
}

public static void main(String[] args) {
    System.out.println(m1());
}
```

Output:
```
9
```

**Explanation:** When JVM sees return statement in try block, it waits for finally block to execute first. If finally also has return, only finally's return value is considered.

### System.exit() Dominates finally Block

**Only case where finally doesn't execute:**
```java
try {
    System.exit(0);  // JVM shuts down
} finally {
    System.out.println("finally");  // Never executes
}
```

---

## Control Flow in try-catch-finally

```java
try {
    statement1;
    statement2;
    statement3;
} catch (Exception e) {
    statement4;
} finally {
    statement5;
}
statement6;
```

### Case 1: No Exception
Executes: 1, 2, 3, 5, 6 (normal termination)

### Case 2: Exception at statement2, catch matched
Executes: 1, 4, 5, 6 (normal termination)

### Case 3: Exception at statement2, catch NOT matched
Executes: 1, 5, then abnormal termination

### Case 4: Exception at statement4
Executes: 1, 2, 3, 4 (partially), 5, then abnormal termination

### Case 5: Exception at statement5 or statement6
Abnormal termination

**Remember:** Catch block is only responsible for exceptions in try block. Exceptions in catch or finally are always abnormal termination.

---

## Nested try-catch-finally

You can write try-catch-finally inside:
- try block
- catch block
- finally block

### Example
```java
try {
    // Outer try
    System.out.println("outer try");
    
    try {
        // Inner try
        System.out.println("inner try");
        System.out.println(10/0);
    } catch (ArithmeticException e) {
        System.out.println("inner catch");
    }
    
    System.out.println("after inner try-catch");
} catch (Exception e) {
    System.out.println("outer catch");
} finally {
    System.out.println("outer finally");
}
```

Output:
```
outer try
inner try
inner catch
after inner try-catch
outer finally
```

---

## Various Possible Combinations of try-catch-finally

### Valid Combinations
1. `try { } catch { }`
2. `try { } catch { } catch { }`
3. `try { } catch { } finally { }`
4. `try { } finally { }`
5. Nested try-catch-finally inside try/catch/finally blocks

### Invalid Combinations

**1. try without catch or finally:**
```java
try {
    // code
}
```
Compile error: `try without catch or finally`

**2. catch without try:**
```java
catch (Exception e) {
    // code
}
```
Compile error: `catch without try`

**3. finally without try:**
```java
finally {
    // code
}
```
Compile error: `finally without try`

**4. Wrong order (try-finally-catch):**
```java
try {
} finally {
} catch (Exception e) {  // INVALID
}
```
Compile error: `catch without try`

**5. Multiple finally blocks:**
```java
try {
} catch (Exception e) {
} finally {
} finally {  // INVALID
}
```
Compile error: `finally without try`

**6. Statements between try and catch:**
```java
try {
}
System.out.println("hello");
catch (Exception e) {  // INVALID
}
```

**7. Curly braces are mandatory:**
```java
// INVALID - even for single statement
try
    System.out.println("try");
catch (Exception e)
    System.out.println("catch");
```

Must use curly braces:
```java
// VALID
try {
    System.out.println("try");
} catch (Exception e) {
    System.out.println("catch");
}
```

---

## throw Keyword

### Purpose
To hand over our created exception object to the JVM manually.

### Syntax
```java
throw new ExceptionType("description");
```

### When to Use
Best used for **customized (user-defined) exceptions** to indicate something went wrong in our program logic.

### Example: Internal Handling
```java
System.out.println(10/0);
```
- JVM internally creates ArithmeticException object
- JVM hands it to itself
- Everything happens internally

### Example: Explicit Handling
```java
throw new ArithmeticException("/ by zero explicitly by Durga");
```

Output:
```
Exception in thread "main" java.lang.ArithmeticException: / by zero explicitly by Durga
    at Test.main
```

**Result is the same, but here we explicitly created and threw the exception.**

### Important Rules

**1. throw with null reference:**
```java
ArithmeticException e = null;
throw e;
```
Result: `NullPointerException` (not ArithmeticException)

**2. After throw, unreachable code:**
```java
System.out.println("statement1");
throw new ArithmeticException();
System.out.println("statement2");  // COMPILE ERROR: unreachable statement
```

**3. throw only works with Throwable types:**
```java
throw new Test();  // INVALID if Test doesn't extend Throwable
```

Compile error: `incompatible types: Test cannot be converted to Throwable`

**Valid:**
```java
class Test extends RuntimeException {
}

throw new Test();  // VALID
```

---

## throws Keyword

### Purpose
To delegate responsibility of exception handling to the caller method.

### When Required
Required **only for checked exceptions**. Unchecked exceptions don't need throws.

### Two Ways to Handle Checked Exceptions

**Method 1: Using try-catch**
```java
public static void main(String[] args) {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        // Handle
    }
}
```

**Method 2: Using throws (delegation)**
```java
public static void main(String[] args) throws InterruptedException {
    Thread.sleep(1000);
}
```

### Example: Delegation Chain
```java
public static void main(String[] args) throws InterruptedException {
    doStuff();
}

public static void doStuff() throws InterruptedException {
    doMoreStuff();
}

public static void doMoreStuff() throws InterruptedException {
    Thread.sleep(1000);
}
```

**Flow:**
1. `doMoreStuff()` delegates to `doStuff()`
2. `doStuff()` delegates to `main()`
3. `main()` delegates to JVM
4. JVM handles (if exception actually occurs, abnormal termination)

### Important Points

**1. try-catch is recommended over throws:**
- throws does NOT prevent abnormal termination
- throws only convinces the compiler

**2. throws required only for checked exceptions:**
```java
// VALID (checked exception)
public static void m1() throws FileNotFoundException {
    PrintWriter pw = new PrintWriter("abc.txt");
}

// VALID but meaningless (unchecked exception)
public static void m1() throws ArithmeticException {
    System.out.println(10/0);
}
```

**3. All throws keywords must be present in delegation chain:**
```java
// INVALID - middle method missing throws
public static void main(String[] args) throws InterruptedException {
    doStuff();  // COMPILE ERROR
}

public static void doStuff() {  // Missing throws
    doMoreStuff();  // COMPILE ERROR
}

public static void doMoreStuff() throws InterruptedException {
    Thread.sleep(1000);
}
```

---

## Various Possible Compile Time Errors

### 1. try without catch or finally
```java
try {
}
```
Error: `try without catch or finally`

### 2. catch without try
```java
catch (Exception e) {
}
```
Error: `catch without try`

### 3. finally without try
```java
finally {
}
```
Error: `finally without try`

### 4. Unreported checked exception
```java
Thread.sleep(1000);  // No try-catch or throws
```
Error: `unreported exception InterruptedException; must be caught or declared to be thrown`

### 5. Exception never thrown in try block (fully checked only)
```java
try {
    System.out.println("hello");
} catch (IOException e) {  // No IO operation in try
}
```
Error: `exception IOException is never thrown in body of corresponding try statement`

**Note:** This rule applies only to **fully checked exceptions**. For unchecked and partially checked, no error.

### 6. Wrong order of catch blocks
```java
try {
    System.out.println(10/0);
} catch (Exception e) {         // Parent first
} catch (ArithmeticException e) {  // Child second - ERROR
}
```
Error: `exception ArithmeticException has already been caught`

### 7. throw only for Throwable types
```java
throw new Test();  // Test doesn't extend Throwable
```
Error: `incompatible types: Test cannot be converted to Throwable`

### 8. Unreachable statement after throw
```java
throw new Exception();
System.out.println("hello");  // ERROR
```
Error: `unreachable statement`

---

## final vs finally vs finalize

### final (Modifier)
A modifier applicable to classes, methods, and variables.

**final class:**
```java
final class Test {
}
class Demo extends Test {  // COMPILE ERROR - cannot extend final class
}
```

**final method:**
```java
class Parent {
    final void m1() { }
}
class Child extends Parent {
    void m1() { }  // COMPILE ERROR - cannot override final method
}
```

**final variable:**
```java
final int x = 10;
x = 20;  // COMPILE ERROR - cannot change final variable
```

### finally (Block)
A block associated with try-catch to maintain cleanup code.

```java
try {
    // Risky code
} catch (Exception e) {
    // Handling code
} finally {
    // Cleanup code - always executes
}
```

**Speciality:** Executes always, whether exception raised or not, handled or not.

### finalize (Method)
A method called by Garbage Collector just before destroying an object.

**Purpose:** To perform cleanup activities (close resources associated with the object).

```java
// Called by GC before destroying object
protected void finalize() throws Throwable {
    // Close resources associated with this object
}
```

**Difference in cleanup:**
- **finally cleanup:** Closes resources opened in try block
- **finalize cleanup:** Closes resources associated with an object before GC destroys it

---

## Customized/User-Defined Exceptions

### What are Customized Exceptions?
Exceptions defined by programmer to meet programming requirements (not Java's built-in exceptions).

### When to Create?
To indicate something went wrong in your business logic.

### Examples
- InsufficientFundsException (bank withdrawal)
- TooYoungException (age < 18)
- TooOldException (age > 60)

### How to Create

**Step 1: Define exception class**
```java
class TooYoungException extends RuntimeException {
    TooYoungException(String message) {
        super(message);
    }
}

class TooOldException extends RuntimeException {
    TooOldException(String message) {
        super(message);
    }
}
```

**Step 2: Use in your program**
```java
public static void main(String[] args) {
    int age = Integer.parseInt(args[0]);
    
    if (age > 60) {
        throw new TooYoungException("Please wait some more time, definitely you will get best match");
    } else if (age < 18) {
        throw new TooOldException("Your age already crossed marriage age, no chance of getting marriage");
    } else {
        System.out.println("Thanks for registration, you will get match details by email");
    }
}
```

### Why extend RuntimeException?
If you extend Exception (checked), you must handle it:
```java
class TooYoungException extends Exception {  // Checked
}

// Now you must handle
if (age > 60) {
    throw new TooYoungException("...");  // COMPILE ERROR - must catch or declare
}
```

By extending RuntimeException (unchecked), no need to handle:
```java
class TooYoungException extends RuntimeException {  // Unchecked
}

// No handling required
if (age > 60) {
    throw new TooYoungException("...");  // VALID
}
```

### Why super(message)?
To make the description available to the Default Exception Handler.

```java
class TooYoungException extends RuntimeException {
    TooYoungException(String message) {
        super(message);  // Passes message to Throwable class
    }
}
```

Without `super(message)`, the exception description won't be displayed.

---

## Top 10 Commonly Raised Exceptions

### 1. ArrayIndexOutOfBoundsException (Unchecked)
**When:** Accessing array element with out-of-range index

```java
int[] a = new int[10];  // Valid indices: 0 to 9
System.out.println(a[0]);    // Valid
System.out.println(a[9]);    // Valid
System.out.println(a[100]);  // ArrayIndexOutOfBoundsException
System.out.println(a[-100]); // ArrayIndexOutOfBoundsException
```

### 2. NullPointerException (Unchecked)
**When:** Performing any operation on null reference

```java
String s = null;
System.out.println(s.length());  // NullPointerException
```

### 3. StackOverflowError (Unchecked)
**When:** Recursive method call without proper termination

```java
public static void m1() {
    m2();
}

public static void m2() {
    m1();  // Infinite recursion -> StackOverflowError
}
```

### 4. ClassCastException (Unchecked)
**When:** Invalid type casting

```java
String s = new String("Durga");
Object o = s;  // Valid - child to parent

Object o = new Object();
String s = (String) o;  // ClassCastException - parent to child
```

**Valid case:**
```java
Object o = new String("Durga");  // Object reference, String object
String s = (String) o;  // Valid - actually String object
```

### 5. NoClassDefFoundError (Unchecked)
**When:** JVM cannot find required .class file at runtime

```java
// Raju.java
class Raju {
    public static void main(String[] args) {
        Rani r = new Rani();
    }
}

// Rani.java
class Rani {
}
```

If you delete `Rani.class` and run `java Raju`:
```
Exception in thread "main" java.lang.NoClassDefFoundError: Rani
```

### 6. ExceptionInInitializerError (Unchecked)
**When:** Exception occurs during static variable initialization or static block execution

```java
class Test {
    static int x = 10/0;  // ArithmeticException during initialization
    
    public static void main(String[] args) {
    }
}
```

Output:
```
Exception in thread "main" java.lang.ExceptionInInitializerError
Caused by: java.lang.ArithmeticException: / by zero
```

**Another example:**
```java
class Test {
    static {
        String s = null;
        System.out.println(s.length());  // NullPointerException in static block
    }
}
```

### 7. IllegalArgumentException (Unchecked)
**When:** Calling a method with inappropriate argument

```java
Thread t = new Thread();
t.setPriority(10);    // Valid - range is 1 to 10
t.setPriority(100);   // IllegalArgumentException - out of valid range
```

### 8. NumberFormatException (Unchecked)
**Child of IllegalArgumentException**

**When:** Converting string to number, but string not properly formatted

```java
int i = Integer.parseInt("10");   // Valid
int j = Integer.parseInt("ten");  // NumberFormatException
```

### 9. IllegalStateException (Unchecked)
**When:** Calling a method at inappropriate time (wrong state)

```java
Thread t = new Thread();
t.start();  // Valid - starts thread
t.start();  // IllegalThreadStateException - already started
```

**Iterator example:**
```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");

Iterator<String> it = list.iterator();
it.remove();  // IllegalStateException - must call next() first

while (it.hasNext()) {
    String obj = it.next();
    it.remove();  // Valid - called after next()
}
```

### 10. AssertionError (Unchecked)
**When:** Assert statement fails during debugging

```java
int x = 10;
assert x > 10;  // Assert statement fails -> AssertionError
```

**Note:** Assertions are disabled by default. Enable with `-ea` flag:
```
java -ea Test
```

---

## 1.7 Version Enhancements

### 1. try-with-resources

**Problem in 1.6 and earlier:**
```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("input.txt"));
    // Use br
} catch (IOException e) {
    // Handle
} finally {
    if (br != null) {
        br.close();  // Programmer must close explicitly
    }
}
```

Problems:
- Complexity increases (must write finally)
- Length of code increases
- Readability decreases

**Solution in 1.7: try-with-resources**
```java
try (BufferedReader br = new BufferedReader(new FileReader("input.txt"))) {
    // Use br
} catch (IOException e) {
    // Handle
}
// No finally needed - br closes automatically
```

**Advantages:**
1. Resources close automatically when try block ends
2. No need to write finally block
3. Complexity reduced
4. Code length reduced
5. Readability improved


### Rules for try-with-resources

**1. Multiple resources allowed (separate with semicolon):**
```java
try (FileReader fr = new FileReader("input.txt");
     PrintWriter pw = new PrintWriter("output.txt")) {
    // Use fr and pw
} catch (IOException e) {
    // Handle
}
// Both resources close automatically
```

**2. All resources must be AutoCloseable:**
A resource is AutoCloseable if its class implements `java.lang.AutoCloseable` interface.

```java
public interface AutoCloseable {
    public void close() throws Exception;
}
```

Almost all IO, database, and network resources already implement AutoCloseable:
- FileReader, FileWriter, BufferedReader, PrintWriter
- Connection, Statement, ResultSet
- Socket, ServerSocket

**3. Resource reference variables are implicitly final:**
Cannot reassign resource variables inside try block:

```java
try (FileReader fr = new FileReader("input.txt")) {
    fr = new FileReader("abc.txt");  // COMPILE ERROR: auto-closeable resource may not be assigned
}
```

**4. try-with-resources without catch/finally is valid (from 1.7):**

Until 1.6:
```java
try {
}  // INVALID - must have catch or finally
```

From 1.7 onwards:
```java
try (Resource r = new Resource()) {
}  // VALID - no catch/finally needed
```

### 1.9 Enhancement to try-with-resources

**1.7 and 1.8:** Must declare resources in try statement

```java
// 1.7/1.8 - MUST declare in try
try (FileReader fr = new FileReader("input.txt")) {
    // Use fr
}
```

**From 1.9:** Can use already declared resources

```java
// 1.9 - Can use already declared
FileReader fr = new FileReader("input.txt");
PrintWriter pw = new PrintWriter("output.txt");

try (fr; pw) {  // Just reference them
    // Use fr and pw
}
```

---

## 2. Multi-catch Block (1.7 Version)

### Problem in 1.6 and Earlier

```java
try {
    // code
} catch (ArithmeticException e) {
    e.printStackTrace();
} catch (NullPointerException e) {
    e.printStackTrace();  // Same handling code
} catch (ClassCastException e) {
    System.out.println(e.getMessage());
} catch (IOException e) {
    System.out.println(e.getMessage());  // Same handling code
}
```

Problems:
- Even with same handling code, need separate catch blocks
- Code length increases
- Readability decreases

### Solution: Multi-catch Block (1.7)

```java
try {
    // code
} catch (ArithmeticException | NullPointerException e) {
    e.printStackTrace();  // Handles both
} catch (ClassCastException | IOException e) {
    System.out.println(e.getMessage());  // Handles both
}
```

**A single catch block that can handle multiple different types of exceptions.**

### Important Rule

Exceptions in multi-catch block **must NOT have parent-child relationship**:

**Invalid:**
```java
try {
    System.out.println(10/0);
} catch (ArithmeticException | Exception e) {  // COMPILE ERROR
    // Exception can already handle ArithmeticException
}
```

Compile error:
```
Alternatives in a multi-catch statement cannot be related by subclassing
```

**Valid:**
```java
try {
    System.out.println(10/0);
} catch (ArithmeticException | NullPointerException e) {  // VALID
    // No parent-child relationship
}
```

### Complete Example

```java
class Test {
    public static void main(String[] args) {
        try {
            System.out.println(10/0);
            String s = null;
            System.out.println(s.length());
        } catch (ArithmeticException | NullPointerException e) {
            System.out.println(e);
        }
    }
}
```

Output (if ArithmeticException occurs first):
```
java.lang.ArithmeticException: / by zero
```

---

## Additional Important Concepts

### Exception Propagation

When an exception occurs in a method and is not handled, it propagates to the caller method.

```java
public static void main(String[] args) {
    doStuff();
}

public static void doStuff() {
    doMoreStuff();
}

public static void doMoreStuff() {
    System.out.println(10/0);  // ArithmeticException occurs
}
```

**Flow:**
1. Exception occurs in `doMoreStuff()`
2. `doMoreStuff()` doesn't handle → propagates to `doStuff()`
3. `doStuff()` doesn't handle → propagates to `main()`
4. `main()` doesn't handle → propagates to JVM
5. JVM's Default Exception Handler handles it → abnormal termination

### Rethrowing an Exception

Converting one exception type to another exception type.

```java
try {
    System.out.println(10/0);  // ArithmeticException
} catch (ArithmeticException e) {
    // Handle original exception
    
    // Convert to different exception
    throw new NullPointerException();
}
```

**Use case:** To maintain consistent exception types in your API layer, or to add more context to exceptions.

---

## Summary of Key Points

### Exception Handling Keywords (5 total)

1. **try** - To maintain risky code
2. **catch** - To maintain handling code
3. **finally** - To maintain cleanup code (always executes)
4. **throw** - To hand over our created exception object to JVM manually (best for customized exceptions)
5. **throws** - To delegate exception handling responsibility to caller (required only for checked exceptions)

### Important Rules

1. Every exception is a class, child of Throwable (directly or indirectly)
2. Checked exceptions: Compiler checks if you handle them
3. Unchecked exceptions: RuntimeException + its children, Error + its children
4. Only 2 partially checked exceptions: Throwable and Exception
5. try must be followed by catch or finally (until 1.6)
6. From 1.7: try-with-resources can be standalone
7. Catch block order: child to parent (not parent to child)
8. throw and throws only work with Throwable types
9. After throw statement, code is unreachable
10. finally block dominates return statement
11. System.exit(0) dominates finally block

### Best Practices

1. Use try-catch when you can handle the exception
2. Use throws only when you can't handle (but try-catch is preferred)
3. Keep try block length as small as possible (only risky code)
4. Use try-with-resources for automatic resource management (1.7+)
5. Use multi-catch for same handling code (1.7+)
6. Create customized exceptions extending RuntimeException (unchecked)
7. Always pass description to super() in custom exceptions

---

This completes the comprehensive Java Exception Handling notes from the lecture transcript.