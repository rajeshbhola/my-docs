---
title: Type Casting
---

**Critical Understanding:**
Through type casting, we are **NOT creating any new object**. We are only providing **another type of reference variable** for the existing object.

This is why it's called **type casting** (or type conversion), not object casting or object conversion.

### Example 1: String to Object Type Casting

```java
String s = new String("Durga");
Object o = (Object) s;
```

**What happens:**
- Only **one object** exists (the String object containing "Durga")
- **Two reference variables** point to it: `s` (String type) and `o` (Object type)
- No new object was created; we just provided another reference type

**These two lines can be combined:**
```java
Object o = new String("Durga");
```

This directly creates a String object and provides an Object type reference for it.

### Example 2: Integer to Number to Object

```java
Integer i = new Integer(10);
Number n = (Number) i;
Object o = (Object) n;
```

**What happens:**
- Only **one object** exists (Integer object with value 10)
- **Three reference variables**: `i` (Integer), `n` (Number), `o` (Object)
- All three point to the same object

**Verification:**
```java
System.out.println(i == n);  // true (same object)
System.out.println(n == o);  // true (same object)
```

**These lines can be combined:**
```java
Object o = new Integer(10);
```

### Understanding Nested Type Casting

**Given class hierarchy:**
```
A (grandparent)
└── B (parent)
    └── C (child)
```

**Example:**
```java
C c = new C();

// Single type cast
(B) c  // Type is B, runtime object is C
       // Equivalent to: B b = new C();

// Nested type cast
(A) (B) c  // Type is A, runtime object is still C
           // Equivalent to: A a = new C();
```

**Key Points:**
- After `(B) c`, the reference type becomes B but runtime object remains C
- After `(A) (B) c`, the reference type becomes A but runtime object still remains C
- The runtime object type **never changes** through type casting

---

## Example-Based Practice Problems

### Example 1: Method Calls with Type Casting

**Code:**
```java
class Parent {
    void m1() { }
}

class Child extends Parent {
    void m2() { }
}

Child c = new Child();
```

**Which method calls are valid?**

```java
c.m1();          // Valid - inherited from Parent
c.m2();          // Valid - Child's own method
((Parent) c).m1();   // Valid - Parent method accessible
((Parent) c).m2();   // INVALID - cannot call child-specific method
```

**Why is the last one invalid?**
- `(Parent) c` creates a Parent type reference to Child object
- Parent reference can only call methods available in Parent class
- `m2()` is child-specific, so it cannot be called

**Principle:** Parent reference can hold child object, but by using that reference we **cannot call child-specific methods**. We can only call methods available in the parent class.

### Example 2: Method Overriding with Type Casting

**Code:**
```java
class A {
    void m1() { System.out.println("A"); }
}

class B extends A {
    void m1() { System.out.println("B"); }
}

class C extends B {
    void m1() { System.out.println("C"); }
}

C c = new C();
```

**Predict the output:**

```java
c.m1();              // Output: C
((B) c).m1();        // Output: C
((A) ((B) c)).m1();  // Output: C
```

**Why all outputs are C?**
- This is **overriding** (not method hiding)
- In overriding, method resolution is always based on **runtime object type**
- Runtime object is always type C
- Therefore, C's m1() executes in all cases

### Example 3: Method Hiding with Type Casting

**Code:**
```java
class A {
    static void m1() { System.out.println("A"); }
}

class B extends A {
    static void m1() { System.out.println("B"); }
}

class C extends B {
    static void m1() { System.out.println("C"); }
}

C c = new C();
```

**Predict the output:**

```java
c.m1();              // Output: C
((B) c).m1();        // Output: B
((A) ((B) c)).m1();  // Output: A
```

**Why different outputs?**
- This is **method hiding** (all methods are static)
- In method hiding, method resolution is based on **reference type**
- `c.m1()` → C reference → C
- `((B) c).m1()` → B reference → B
- `((A) ((B) c)).m1()` → A reference → A

### Example 4: Variable Resolution with Type Casting

**Code:**
```java
class A {
    int x = 777;
}

class B extends A {
    int x = 888;
}

class C extends B {
    int x = 999;
}

C c = new C();
```

**Predict the output:**

```java
System.out.println(c.x);              // Output: 999
System.out.println(((B) c).x);        // Output: 888
System.out.println(((A) ((B) c)).x);  // Output: 777
```

**Why different outputs?**
- **Variable resolution is always based on reference type**, not runtime object
- Overriding concept is **NOT applicable for variables**
- `c.x` → C reference → 999
- `((B) c).x` → B reference → 888
- `((A) ((B) c)).x` → A reference → 777

---

## Summary of Key Principles

### 1. Type Casting Creates References, Not Objects
- Type casting only creates a new reference variable
- The actual object remains the same
- Only the reference type changes

### 2. Method Resolution Rules

| Scenario | Resolution Based On | Determined By |
|----------|-------------------|---------------|
| Overriding (non-static methods) | Runtime object type | JVM |
| Method hiding (static methods) | Reference type | Compiler |
| Variable access | Reference type | Compiler |

### 3. Parent Reference Restrictions
- Parent reference can hold child object
- But can only call methods available in parent class
- Cannot call child-specific methods

### 4. What Changes vs What Doesn't

**Changes through type casting:**
- Reference variable type

**Never changes:**
- The actual runtime object
- The object's class type
- The object's memory location