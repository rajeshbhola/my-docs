---
title: Constructor
---

## Purpose of Constructors

**The main purpose of a constructor is to perform initialization of an object, NOT to create an object.**

### Why We Need Constructors

```java
class Student {
    String name;
    int rollNumber;
}
```

**Without initialization:**
- All 600 student objects would have: name = null, rollNumber = 0
- Meaningless - all students identical

**With constructor:**
```java
class Student {
    String name;
    int rollNumber;
    
    Student(String name, int rollNumber) {
        this.name = name;
        this.rollNumber = rollNumber;
    }
}

// Now we can create:
Student s1 = new Student("Durga", 101);  // name="Durga", roll=101
Student s2 = new Student("Ravi", 102);   // name="Ravi", roll=102
```

**Benefits:**
1. Different values for each object
2. Code length doesn't increase
3. Clean, maintainable initialization

---

## Where to Initialize Objects?

| Approach | Valid? | Problem |
|----------|--------|---------|
| At declaration: `String name = "Durga";` | ❌ | All objects get same values |
| In instance block: `{ name = "Durga"; }` | ❌ | All objects get same values |
| After creation: `s1.name = "Durga";` | ❌ | Code length increases drastically |
| **In constructor** | ✅ | **Best approach** |

---

## Constructor vs Instance Block

### Constructor
- **Purpose:** Initialize object with specific values
- **When used:** For initialization based on provided arguments

### Instance Block
- **Purpose:** Perform activities OTHER than initialization for every object creation
- **When used:** 
  - Updating database records
  - Incrementing count
  - Logging object creation

### Example: Counting Objects Created

```java
class Test {
    static int count = 0;
    
    {  // Instance block - best for counting
        count++;  // Only write once!
    }
    
    Test() { }           // Constructor 1
    Test(int i) { }      // Constructor 2
    Test(double d) { }   // Constructor 3
    
    public static void main(String[] args) {
        Test t1 = new Test();
        Test t2 = new Test(10);
        Test t3 = new Test(10.5);
        System.out.println("Number of objects created: " + count);  // 3
    }
}
```

**Why instance block is better here:**
- Write `count++` only once
- Works for all constructors
- No code redundancy

**Key Points:**
- Constructor and instance block execute for every object creation
- **Instance block executes BEFORE constructor**
- Both have different purposes - cannot replace one with the other

---

## Rules for Writing Constructors

### Rule 1: Name Must Match Class Name

```java
class Test {
    Test() { }  // Valid - same name as class
}
```

### Rule 2: Return Type Not Applicable

```java
class Test {
    Test() { }        // Valid - no return type
    void Test() { }   // Invalid as constructor, treated as METHOD
}
```

**Important:** If you add return type, it becomes a method, not a constructor!

### Rule 3: Only Specific Modifiers Allowed

**Allowed modifiers:** `public`, `private`, `protected`, `default`

```java
class Test {
    public Test() { }     // Valid
    private Test() { }    // Valid
    static Test() { }     // INVALID - Compile error: "modifier static not allowed here"
}
```

**By mistake adding return type:**
```java
class Test {
    void Test() {  // This is a METHOD, not constructor
        System.out.println("Method");
    }
}
```

**Legal but stupid:** Having a method with same name as class is allowed but not recommended.

---

## Default Constructor

### Prototype of Default Constructor

**Three characteristics:**

1. **Always no-argument constructor**
   - Every default constructor is no-arg
   - But not every no-arg constructor is default
   - Default = generated by compiler
   - Programmer-written no-arg constructor ≠ default

2. **Access modifier same as class**
   ```java
   public class Test { }
   // Compiler generates: public Test() { super(); }
   
   class Test { }
   // Compiler generates: Test() { super(); }
   ```

3. **Contains only one line: `super();`**
   - No-argument call to superclass constructor

### When Does Compiler Generate Default Constructor?

**Compiler generates default constructor if and only if we don't write ANY constructor.**

```java
// Case 1: No constructor written
class Test { }
// Compiler generates: Test() { super(); }

// Case 2: Constructor written
class Test {
    Test(int i) { }
}
// Compiler does NOT generate default constructor
```

### Compiler's Two-Level Checking

**Level 1:** Did programmer write any constructor?
- No → Generate default constructor
- Yes → Don't generate default constructor

**Level 2:** Did programmer write constructor properly?
- First line should be `super()` or `this()`
- If missing, compiler adds `super()`

**Examples:**

```java
// Programmer code         →  Compiler-generated code
class Test { }            →  class Test { Test() { super(); } }

class Test {              →  class Test {
    Test() { }            →      Test() { super(); }  // Added by compiler
}                         →  }

class Test {              →  class Test {
    Test() {              →      Test() {
        super();          →          super();  // No change needed
    }                     →      }
}                         →  }
```

---

## `super()` and `this()` - Constructor Calls

### Rules for Using `super()` and `this()`

**Rule 1: Can use only in constructors, only in first line**

```java
class Test {
    Test() {
        System.out.println("Constructor");
        super();  // INVALID - Compile error: "call to super must be first statement"
    }
}
```

**Rule 2: Can use only ONE, not both**

```java
class Test {
    Test() {
        super();
        this(10);  // INVALID - Compile error: "call to this must be first statement"
    }
}
```

**Rule 3: Can use only inside constructor, not in methods**

```java
class Test {
    public void m1() {
        super();  // INVALID - Compile error: "call to super must be first statement in constructor"
    }
}
```

---

## `super` vs `this` Keywords (without parentheses)

### Comparison Table

| Feature | `super()` / `this()` | `super` / `this` |
|---------|---------------------|------------------|
| **Purpose** | Constructor calls | Keywords to refer to instance members |
| **Usage location** | Only in constructors, first line | Anywhere except static area |
| **Frequency** | Only once per constructor | Any number of times |
| **Example** | `super();` calls parent constructor | `super.x` accesses parent's variable |

### Example: Keyword Usage

```java
class Parent {
    int x = 100;
}

class Child extends Parent {
    int x = 200;
    
    void m1() {
        System.out.println(this.x);   // 200 (current class)
        System.out.println(super.x);  // 100 (parent class)
    }
}
```

### Cannot Use in Static Area

```java
class Test {
    public static void main(String[] args) {
        System.out.println(super.hashCode());  
        // INVALID - Compile error: "non-static variable super cannot be 
        // referenced from a static context"
    }
}
```

---

## Overloaded Constructors

### Definition

**Overloaded constructors:** Multiple constructors in same class with same name but different argument types.

```java
class Test {
    Test() {                           // No-arg constructor
        this(10);
        System.out.println("No-arg Constructor");
    }
    
    Test(int i) {                      // int-arg constructor
        this(10.5);
        System.out.println("int-arg Constructor");
    }
    
    Test(double d) {                   // double-arg constructor
        System.out.println("double-arg Constructor");
    }
}
```

### Constructor Calls and Output

```java
Test t1 = new Test();      // Output: double-arg, int-arg, No-arg
Test t2 = new Test(10);    // Output: double-arg, int-arg
Test t3 = new Test(10.5);  // Output: double-arg
Test t4 = new Test(10L);   // Output: double-arg (long promoted to double)
```

**Key Point:** Automatic promotion in overloading applies to constructors too (long → float → double).

---

## Inheritance and Overriding for Constructors

### Inheritance: NOT Applicable

```java
class Parent {
    void m1() { }      // Methods: inherited
    Parent() { }       // Constructors: NOT inherited
}

class Child extends Parent {
    void m2() { }
}

// Child has 2 methods (m1, m2) but only its own constructor
```

**For constructors:**
- Inheritance concept: ❌ Not applicable
- Overriding concept: ❌ Not applicable
- Overloading concept: ✅ Applicable

---

## Every Class Has Constructors

**Rule:** Every class in Java (including abstract classes) can contain constructors, but interfaces cannot.

### Why Abstract Classes Have Constructors

Abstract classes can have constructors for initialization even though we can't create objects directly.

### Why Interfaces Cannot Have Constructors

- Constructors initialize instance variables
- Interfaces have only static variables (no instance variables)
- No instance variables → No need for constructors

```java
class Test {
    Test() { }           // Valid
}

abstract class Test {
    Test() { }           // Valid
}

interface Test {
    Test() { }           // INVALID - Compile error
}
```

---

## Important Cases

### Case 1: Recursive Constructor Invocation

**Recursive method call:** Runtime exception (StackOverflowError)
**Recursive constructor invocation:** Compile-time error

```java
// Recursive method call - Runtime exception
class Test {
    public static void m1() {
        m2();
    }
    
    public static void m2() {
        m1();  // StackOverflowError when called
    }
    
    public static void main(String[] args) {
        System.out.println("Hello");  // Only this executes
    }
}
```

```java
// Recursive constructor invocation - Compile error
class Test {
    Test() {
        this(10);  // Calls second constructor
    }
    
    Test(int i) {
        this();    // Calls first constructor
        // Compile error: "recursive constructor invocation"
    }
}
```

### Case 2: Parent Constructor Matching

```java
// Case 1: Valid
class P { }
class C extends P { }
// Compiler generates: P() { super(); } and C() { super(); }

// Case 2: Valid
class P {
    P() { }
}
class C extends P { }
// Compiler generates: C() { super(); } - matches P()

// Case 3: INVALID
class P {
    P(int i) { }  // Only int-arg constructor
}
class C extends P { }
// Compiler tries: C() { super(); } but P() doesn't exist!
// Compile error: "cannot find symbol: constructor P()"
```

**Best practices:**
1. If parent has any-arg constructor, take care when writing child classes
2. When writing any-arg constructor, also write no-arg constructor

### Case 3: Checked Exceptions in Constructors

```java
// Parent constructor throws checked exception
import java.io.*;

class P {
    P() throws IOException { }
}

class C extends P { }
// Compiler generates: C() { super(); }
// But super() throws IOException - must handle!
// Compile error: "unreported exception java.io.IOException in default constructor"
```

**Solution:** Child constructor must throw same exception or its parent

```java
class C extends P {
    C() throws IOException { }      // Valid - same exception
    C() throws Exception { }        // Valid - parent of IOException
    C() throws Throwable { }        // Valid - grandparent
}
```

**Note:** Cannot use try-catch because `super()` must be first line.

---

## Summary: True or False Statements

| Statement | Answer | Reason |
|-----------|--------|--------|
| Main purpose of constructor is to create object | False | Purpose is to initialize object |
| Main purpose is to initialize object | True | Correct |
| Constructor name need not match class name | False | Must match |
| Return type concept applicable (even void) | False | No return type allowed |
| Can apply any modifier to constructor | False | Only public/private/protected/default |
| Default constructor generated by JVM | False | Generated by compiler |
| Compiler always generates default constructor | False | Only if no constructor written |
| Every no-arg constructor is default | False | Only compiler-generated is default |
| Default constructor is always no-arg | True | Correct |
| First line should be super or this; if not, compiler adds `this()` | False | Compiler adds `super()` |
| Overloading and overriding both applicable | False | Only overloading |
| Inheritance applicable but not overriding | False | Neither applicable |
| Only concrete classes have constructors | False | Abstract classes can too |
| Interfaces can have constructors | False | No instance variables, no need |
| Recursive constructor invocation is runtime exception | False | Compile-time error |
| Child must throw same checked exception or its child | False | Must throw same or its PARENT |

---

## Key Takeaways

1. **Constructors initialize objects, they don't create them** (new operator creates)
2. **Constructor and instance block serve different purposes** - can't replace one with other
3. **Instance block executes before constructor**
4. **Compiler generates default constructor only if no constructor written**
5. **`super()` or `this()` must be first line in constructor**
6. **Overloading works, inheritance/overriding don't work for constructors**
7. **When writing any-arg constructor, also write no-arg constructor** (best practice)
8. **Recursive constructor invocation = compile error** (not runtime)